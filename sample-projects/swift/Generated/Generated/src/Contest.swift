/**
 * Contest.swift
 *
 * Generated by JSON Model Generator v0.0.4 on Aug 12, 2016
 * https://github.com/intere/generator-json-models
 *
 * The generator tool is licensed under the LGPL: http://www.gnu.org/licenses/lgpl-3.0.html#content
 */

import Foundation

class Contest {
    var theId: String?
    var title: String?
    var typeName: String?
    var stateName: String?
    var imageUrl: String?
    var theDescription: String?
    var startDate: NSDate?
    var endDate: NSDate?
    var userIDs: [String]?
    var results: [ContestResults]?
    var createdDate: NSDate?
    var latitude: Double?
    var longitude: Double?
    var purseDescription: String?
    var purseImageUrl: String?
    var pursePrizeValue: String?
    var purseTitle: String?
    var purseType: String?
    var runnerUpDescription: String?
    var runnerUpPrizeValue: String?
    var runnerUpPurseImageUrl: String?
    var runnerUpTitle: String?
    var scored: Bool?
    var size: Int?
    var sponsor: ContestSponsor?
    var state: Int?
    var trackIDs: [String]?
    var theType: Int?

}

// MARK: - Serialization

extension Contest {

    /**
    Serializes this Contest to a Dictionary.
    - Returns: A Map which represents this object as a serialized object
    */
    func toMap() -> [String: AnyObject] {
        var dict = [String: AnyObject]()

        dict["id"] = theId
        dict["title"] = title
        dict["typeName"] = typeName
        dict["stateName"] = stateName
        dict["imageUrl"] = imageUrl
        dict["description"] = theDescription
        dict["startDate"] = Contest.toEpochDateInt(startDate)
        dict["endDate"] = Contest.toEpochDateInt(endDate)
        // Array Subtype = String
        dict["userIDs"] = userIDs
        dict["results"] =  ContestResults.toMapArray(results)
        dict["createdDate"] = Contest.toEpochDateInt(createdDate)
        dict["latitude"] = latitude
        dict["longitude"] = longitude
        dict["purseDescription"] = purseDescription
        dict["purseImageUrl"] = purseImageUrl
        dict["pursePrizeValue"] = pursePrizeValue
        dict["purseTitle"] = purseTitle
        dict["purseType"] = purseType
        dict["runnerUpDescription"] = runnerUpDescription
        dict["runnerUpPrizeValue"] = runnerUpPrizeValue
        dict["runnerUpPurseImageUrl"] = runnerUpPurseImageUrl
        dict["runnerUpTitle"] = runnerUpTitle
        dict["scored"] = scored
        dict["size"] = size
        if let sponsor = sponsor {
            dict["sponsor"] = sponsor.toMap()
        }
        dict["state"] = state
        // Array Subtype = String
        dict["trackIDs"] = trackIDs
        dict["type"] = theType

        return dict
    }

    /**
    Converts the provided array of Contest Objects to an array of dictionaries.
    - Parameter models: An array of Contest Objects to be converted to an array of dictionaries.
    - Returns: An array of Dictionaries
    */
    class func toMapArray(models: [Contest]?) -> [[String: AnyObject]]? {
        guard let models = models else {
            return nil
        }
        var maps = [[String: AnyObject]]()

        for model in models {
            maps.append(model.toMap())
        }

        return maps
    }

    /**
    Converts this model to JSON Data.
    - Returns: Optional JSON Data (returns nil if there's a problem serializing the map).
    */
    func toJsonData() -> NSData? {
        let dict = toMap()
        do {
            return try NSJSONSerialization.dataWithJSONObject(dict, options: .PrettyPrinted)
        } catch {
            print("Error serializing this model to JSON: \(dict)")
        }

        return nil
    }

	/**
	Converts the provided array of models to JSON Data.
	- Parameter array: Array of Contest objects to be serialized.
	- Returns: NSData that contains the serialized objects, or nil if there's a problem serializing them.
	*/
	class func toJsonData(array: [Contest]) -> NSData? {
		let mapArray = toMapArray(array) as! AnyObject
		do {
			return try NSJSONSerialization.dataWithJSONObject(mapArray, options: .PrettyPrinted)
		} catch {
			print("Error serializing array of models to JSON: \(mapArray)")
		}
		return nil
	}

	/**
	Converts this model to a JSON String.
	- Returns: Optional String (nil if there's a problem serializing the map to Data or converting it to a UTF-8 String).
	*/
	func toJsonString() -> String? {
	    guard let data = toJsonData() else {
	        return nil
        }

        return NSString(data: data, encoding: NSUTF8StringEncoding) as? String
	}

    /**
    Converts the provided array of models to a JSON String.
    - Parameter array: Array of Contest objects to be serialized
    - Returns: Optional String (nil if there's a problem serializing to NSData or converting to a UTF-8 String).
    */
    class func toJsonString(array: [Contest]) -> String? {
        guard let data = toJsonData(array) else {
            return nil
        }

        return NSString(data: data, encoding: NSUTF8StringEncoding) as? String
    }

}

// MARK: - Deserialization

extension Contest {

    /**
    Gets you a Contest object from the provided map
    - Parameter map: The Map to read the data from.
    - Returns: A Contest object (assuming the map you provided is non-nil)
    */
    class func fromMap(map: [String:AnyObject]?) -> Contest? {
        guard let map = map else {
            return nil
        }

        let model = Contest()
        model.theId = map["id"] as? String
        model.title = map["title"] as? String
        model.typeName = map["typeName"] as? String
        model.stateName = map["stateName"] as? String
        model.imageUrl = map["imageUrl"] as? String
        model.theDescription = map["description"] as? String
        model.startDate = Contest.fromEpochDateInt(map["startDate"] as? Int)
        model.endDate = Contest.fromEpochDateInt(map["endDate"] as? Int)
        model.userIDs = map["userIDs"] as? [String]
        model.results = map["results"] as? [ContestResults]
        model.createdDate = Contest.fromEpochDateInt(map["createdDate"] as? Int)
        model.latitude = map["latitude"] as? Double
        model.longitude = map["longitude"] as? Double
        model.purseDescription = map["purseDescription"] as? String
        model.purseImageUrl = map["purseImageUrl"] as? String
        model.pursePrizeValue = map["pursePrizeValue"] as? String
        model.purseTitle = map["purseTitle"] as? String
        model.purseType = map["purseType"] as? String
        model.runnerUpDescription = map["runnerUpDescription"] as? String
        model.runnerUpPrizeValue = map["runnerUpPrizeValue"] as? String
        model.runnerUpPurseImageUrl = map["runnerUpPurseImageUrl"] as? String
        model.runnerUpTitle = map["runnerUpTitle"] as? String
        model.scored = map["scored"] as? Bool
        model.size = map["size"] as? Int
        model.sponsor = ContestSponsor.fromMap(map["sponsor"] as? [String: AnyObject])
        model.state = map["state"] as? Int
        model.trackIDs = map["trackIDs"] as? [String]
        model.theType = map["type"] as? Int
        return model
    }

    /**
    Creates an Array of Contest objects for the provided Array of Maps.
    - Parameter mapArray: An array of Maps, assumes that each map is a serialized Contest.
    - Returns: An array of Contest objects (should be 1 to 1).
    */
    class func fromArrayOfMaps(mapArray: [[String:AnyObject]]?) -> [Contest] {
        guard let mapArray = mapArray else {
            return []
        }

        var modelArray = [Contest]()

        for map in mapArray {
            guard let model = fromMap(map) else {
                continue
            }
            modelArray.append(model)
        }

        return modelArray
    }

    /**
    Gives you back a collection of Contest objects for the provided JSON Serialized Data.  This method handles both a single object (map) and an array of objects (array of maps).
    - Parameter data: The NSData (optional) to pull the objects from.
    - Returns: An array of Contest objects that were deserialized from the provided data.
    */
    class func fromData(data: NSData?) -> [Contest] {
        guard let data = data else {
            return []
        }

        do {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: .AllowFragments)

            // If we have an array of dictionaries:
            if let jsonArray = jsonData as? [[String:AnyObject]] {
                return fromArrayOfMaps(jsonArray)
            } else if let jsonMap = jsonData as? [String:AnyObject] {
                if let model = fromMap(jsonMap) {
                    return [model]
                }
            } else {
                print("Unknown JSON Data type: \(jsonData)")
            }
        } catch {
            print("Error deserializing json data")
        }

        return []
    }

	/**
	 Gives you back a collection of Contest objects after deserializing them from a String to Data, Data to a Dictionary and then finally to a Model Object.
	 - Parameter json: The (UTF-8) JSON String to deserialize into Contest objects.
	 - Returns: An Array of Contest objects.
	*/
	class func fromJson(json: String) -> [Contest] {
		let data = (json as NSString).dataUsingEncoding(NSUTF8StringEncoding)
		return fromData(data)
	}

}

// MARK: - Date Methods

extension Contest {

    	class func fromEpochDateInt(dateInt: Int?) -> NSDate? {
    	    guard let dateInt = dateInt else {
    	        return nil
    	    }

    		let dateDouble = NSTimeInterval(Double(dateInt) / 1000)
    		return NSDate(timeIntervalSince1970: dateDouble)
    	}

    	class func toEpochDateInt(date: NSDate?) -> Int? {
    	    guard let date = date else {
    			return nil
    		}

    		return Int(date.timeIntervalSince1970 * 1000)
    	}

}