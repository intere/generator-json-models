package com.intere.generator.builder.generation;

import java.io.File;
import java.util.Iterator;

import org.codehaus.jackson.JsonNode;

import com.intere.generator.App;
import com.intere.generator.builder.interpreter.JsonLanguageInterpreter;
import com.intere.generator.builder.interpreter.RubyInterpreter;
import com.intere.generator.deserializer.JsonDeserializer;
import com.intere.generator.deserializer.JsonNodeUtils;

public class RubyGeneration extends CodeGeneration {
	private static final RubyInterpreter INTERPRETER = new RubyInterpreter();

	@Override
	public String generateHeaderFile(JsonDeserializer deserializer) {
		return null;	// Ruby doesn't have Header Files
	}
	
	private String getTabs(JsonDeserializer deserializer, int index) {
		StringBuilder builder = new StringBuilder();
		
		if(null!=deserializer.getNamespace()) {
			builder.append("\t");
		}
		for(int i=0;i<index;i++) {
			builder.append("\t");
		}
		
		return builder.toString();
	}

	@Override
	public String generateImplementationFile(JsonDeserializer deserializer) {
		String className = deserializer.getName();
		String filename = getInterpreter().buildFilenameFromClassname(className);
		String namespace = deserializer.getNamespace();
		JsonNode node = deserializer.getNode();

		StringBuilder builder = new StringBuilder();
		builder.append("#\n" +
				"#  " + filename + ".rb\n" +
				"#  Generated by JSON Model Generator v" + App.getVersion() + " on " + getDate() + ".\n" +
				"#    https://github.com/intere/generator-json-models\n" +
				"#\n" +
				"#    The generator tool is licensed under the LGPL: http://www.gnu.org/licenses/lgpl-3.0.html#content\n" +
				"#\n" +
				"#\n\n");

		if(null != namespace) {
			builder.append("module " + namespace + "\n");
		}

		builder.append(getTabs(deserializer, 0) + "class " + className + " < JsonModel\n");

		Iterator<String> iter = node.getFieldNames();
		while(iter.hasNext()) {
			String name = iter.next();
			builder.append(buildPropertyDeclaration(node.get(name), className, name, getTabs(deserializer,1)));
		}

		// TODO Serialize / Deserialize declarations:

		builder.append(getTabs(deserializer, 0) + "end\n");
		
		if(null != namespace) {
			builder.append("\nend\n");
		}

		return builder.toString();
	}

	@Override
	public String generateTestFile(JsonDeserializer deserializer, String jsonFilename, String jsonTestFilename) {
		// TODO Auto-generated method stub
		return null;
	}

	public String buildPropertyDeclaration(JsonNode node, String className, String name, String tabs) {
		String propName = getInterpreter().cleanVariableName(name);
		String subClass = getInterpreter().buildSubClassName(className, name);
		
		if(JsonNodeUtils.isArrayOfObjects(node)) {
			return "\n" + tabs + "def " + propName + "\n" +
					tabs + "\t@" + name + "||= @json.try(:[], '" + name + "').map {|" + name + "|" + subClass + ".new(" + name + ")}\n" + 
					tabs + "end\n";
		} else if(JsonNodeUtils.isArrayofArrays(node) || JsonNodeUtils.isArray(node)) {
			return "\n" + tabs + "def " + propName + "\n" +
					tabs + "\t@" + name + "||= @json.try(:[], '" + name + "')\n" + 
					tabs + "end\n";
		} else if(node.isObject()) {
			return "\n" + tabs + "def " + propName + "\n" +
					tabs + "\t@" + propName + " ||= " + subClass + ".new @json.try(:[], '" + name + "')\n" +
					tabs + "end\n";
		} else {
			return "\n" + tabs + "def " + propName + "\n" +
					tabs + "\t@json.try(:[], '" + name + "')\n" +
					tabs + "end\n";
		}
	}

	@Override
	public JsonLanguageInterpreter getInterpreter() {
		return INTERPRETER;
	}

}
