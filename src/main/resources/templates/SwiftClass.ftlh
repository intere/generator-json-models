/**
 * ${filename}
 *
 * Generated by JSON Model Generator v${version} on ${date?date}
 * https://github.com/intere/generator-json-models
 *
 * The generator tool is licensed under the LGPL: http://www.gnu.org/licenses/lgpl-3.0.html#content
 */

import Foundation

class ${model.className} {
    <#list properties as property>
    <#switch property.dataType>
        <#case "CLASS">
    var ${property.alias}: ${property.type}?
        <#break>

        <#case "DATE">
    var ${property.alias}: NSDate?
        <#break>

        <#case "ARRAY">
    var ${property.alias}: ${property.swiftArrayType}?
        <#break>

        <#default>
    var ${property.alias}: ${property.dataType.swiftName}?
        <#break>
    </#switch>
    </#list>

    // MARK: - Initializers

    init() {
    }

    init(map: [String: Any]) {
        copy(fromMap: map)
    }

    init(from${model.className} other: ${model.className}) {
        copy(fromMap: other.asMap)
    }
}

// MARK: - Serialization

extension ${model.className} {

    /**
    Serializes this ${model.className} to a Dictionary.
    - Returns: A Map which represents this object as a serialized object
    */
    var asMap: [String: Any] {
        var dict = [String: Any]()

        <#list properties as property>
        <#if !property.isTransient>
        <#switch property.dataType>
            <#case "CLASS">
        if let ${property.alias} = ${property.alias} {
            dict["${property.name}"] = ${property.alias}.asMap
        }
            <#break>

            <#case "DATE">
        dict["${property.name}"] = ${model.className}.toEpochDateInt(${property.alias})
            <#break>

            <#case "ARRAY">
            <#if property.arraySubTypeProperty.dataType == "CLASS">
        dict["${property.name}"] =  ${property.arraySubType}.toMapArray(models: ${property.alias})
            <#else>
        dict["${property.name}"] = ${property.alias}
            </#if>
            <#break>

            <#default>
        dict["${property.name}"] = ${property.alias}
            <#break>
        </#switch>
        </#if>
        </#list>

        return dict
    }

    /**
    Converts the provided array of ${model.className} Objects to an array of dictionaries.
    - Parameter models: An array of ${model.className} Objects to be converted to an array of dictionaries.
    - Returns: An array of Dictionaries
    */
    class func toMapArray(models: [${model.className}]?) -> [[String: Any]]? {
        guard let models = models else {
            return nil
        }
        var maps = [[String: Any]]()

        for model in models {
            maps.append(model.asMap)
        }

        return maps
    }

    /**
    Converts this model to JSON Data.
    - Returns: Optional JSON Data (returns nil if there's a problem serializing the map).
    */
    func toJsonData() -> Data? {
        let dict = asMap
        do {
            return try JSONSerialization.data(withJSONObject: dict, options: .prettyPrinted)
        } catch {
            print("Error serializing this model to JSON: \(dict)")
        }

        return nil
    }

	/**
	Converts the provided array of models to JSON Data.
	- Parameter array: Array of ${model.className} objects to be serialized.
	- Returns: Data that contains the serialized objects, or nil if there's a problem serializing them.
	*/
	class func toJsonData(array: [${model.className}]) -> Data? {
      guard let mapArray = toMapArray(models: array) else {
          return nil
      }
		do {
			return try JSONSerialization.data(withJSONObject: mapArray, options: .prettyPrinted)
		} catch {
			print("Error serializing array of models to JSON: \(mapArray)")
		}
		return nil
	}

	/**
	Converts this model to a JSON String.
	- Returns: Optional String (nil if there's a problem serializing the map to Data or converting it to a UTF-8 String).
	*/
	func toJsonString() -> String? {
	    guard let data = toJsonData() else {
	        return nil
        }

        return NSString(data: data, encoding: String.Encoding.utf8.rawValue) as? String
	}

    /**
    Converts the provided array of models to a JSON String.
    - Parameter array: Array of ${model.className} objects to be serialized
    - Returns: Optional String (nil if there's a problem serializing to Data or converting to a UTF-8 String).
    */
    class func toJsonString(array: [${model.className}]) -> String? {
        guard let data = toJsonData(array: array) else {
            return nil
        }

        return NSString(data: data, encoding: String.Encoding.utf8.rawValue) as? String
    }

}

// MARK: - Deserialization

extension ${model.className} {

    /**
    Gets you a ${model.className} object from the provided map
    - Parameter map: The Map to read the data from.
    - Returns: A ${model.className} object (assuming the map you provided is non-nil)
    */
    class func fromMap(map: [String:Any]?) -> ${model.className}? {
        guard let map = map else {
            return nil
        }

        let model = ${model.className}()
        model.copy(fromMap: map)
        return model
    }

    fileprivate func copy(fromMap map: [String: Any]) {
        <#list properties as property>
        <#if !property.isTransient>
            <#switch property.dataType>
                <#case "CLASS">
        ${property.alias} = ${property.type}.fromMap(map["${property.name}"] as? [String: Any])
                <#break>

                <#case "DATE">
        ${property.alias} = ${model.className}.fromEpochDateInt(map["${property.name}"] as? Int)
                <#break>

                <#case "ARRAY">
                <#if property.arraySubTypeProperty.dataType == "CLASS">
        ${property.alias} = ${property.arraySubType}.fromArrayOfMaps(mapArray: map["${property.name}"] as? [[String: Any]])
                <#else>
        ${property.alias} = map["${property.name}"] as? [${property.arraySubType}]
                </#if>
                <#break>

                <#default>
        ${property.alias} = map["${property.name}"] as? ${property.dataType.swiftName}
                <#break>
            </#switch>
        </#if>
        </#list>
    }

    /**
    Creates an Array of ${model.className} objects for the provided Array of Maps.
    - Parameter mapArray: An array of Maps, assumes that each map is a serialized ${model.className}.
    - Returns: An array of ${model.className} objects (should be 1 to 1).
    */
    class func fromArrayOfMaps(mapArray: [[String: Any]]?) -> [${model.className}]? {
        guard let mapArray = mapArray else {
            return nil
        }

        var modelArray = [${model.className}]()

        for map in mapArray {
            guard let model = fromMap(map: map) else {
                continue
            }
            modelArray.append(model)
        }

        return modelArray
    }

    /**
    Gives you back a collection of ${model.className} objects for the provided JSON Serialized Data.  This method handles both a single object (map) and an array of objects (array of maps).
    - Parameter data: The Data (optional) to pull the objects from.
    - Returns: An array of ${model.className} objects that were deserialized from the provided data.
    */
    class func fromData(data: Data?) -> [${model.className}]? {
        guard let data = data else {
            return []
        }

        do {
            let jsonData = try JSONSerialization.jsonObject(with: data as Data, options: .allowFragments)

            // If we have an array of dictionaries:
            if let jsonArray = jsonData as? [[String: Any]] {
                return fromArrayOfMaps(mapArray: jsonArray)
            } else if let jsonMap = jsonData as? [String: Any] {
                if let model = fromMap(map: jsonMap) {
                    return [model]
                }
            } else {
                print("Unknown JSON Data type: \(jsonData)")
            }
        } catch {
            print("Error deserializing json data")
        }

        return []
    }

	/**
	 Gives you back a collection of ${model.className} objects after deserializing them from a String to Data, Data to a Dictionary and then finally to a Model Object.
	 - Parameter json: The (UTF-8) JSON String to deserialize into ${model.className} objects.
	 - Returns: An Array of ${model.className} objects.
	*/
	class func fromJson(json: String) -> [${model.className}]? {
		let data = (json as NSString).data(using: String.Encoding.utf8.rawValue)
		return fromData(data: data)
	}

}

<#if model.hasDate()>
// MARK: - Date Helpers

extension ${model.className} {

    	class func fromEpochDateInt(dateInt: Int?) -> NSDate? {
    	    guard let dateInt = dateInt else {
    	        return nil
    	    }

    		let dateDouble = NSTimeInterval(Double(dateInt) / 1000)
    		return NSDate(timeIntervalSince1970: dateDouble)
    	}

    	class func toEpochDateInt(date: NSDate?) -> Int? {
    	    guard let date = date else {
    			return nil
    		}

    		return Int(date.timeIntervalSince1970 * 1000)
    	}

}
</#if>
